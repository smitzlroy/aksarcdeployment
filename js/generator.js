/**
 * Template Generators - Bicep, ARM, Terraform
 */

class TemplateGenerator {
    /**
     * Generate Bicep template
     */
    static generateBicep(plan) {
        const { clusterConfig, availabilitySetConfig, securityConfig } = plan;
        const { clusterName, location, kubernetesVersion, controlPlaneCount, nodePools } = clusterConfig;
        const enableDefender = securityConfig?.enableDefender || false;
        const enablePolicy = securityConfig?.enablePolicy !== false; // Default true

        let template = `// AKS Arc Cluster Deployment
// Generated by AKS Arc Deployment Tool
// Generated: ${new Date().toISOString()}
//
// High Availability: Availability sets are enabled by default in AKS Arc
// - Control plane VMs automatically spread across physical hosts
// - Each node pool has its own availability set with anti-affinity rules
// - VMs automatically rebalance when hosts recover from outages
// - Physical hosts: ${availabilitySetConfig.faultDomains}
//
// Security Configuration:
// - Microsoft Defender for Containers: ${enableDefender ? 'ENABLED (~$6.87/vCore/month)' : 'DISABLED'}
// - Azure Policy for Kubernetes: ${enablePolicy ? 'ENABLED (FREE)' : 'DISABLED'}
//
// Recommendation: Configure pod anti-affinity rules in your workload deployments
// for additional resilience across nodes.

targetScope = 'resourceGroup'

@description('Name of the AKS Arc cluster')
param clusterName string = '${clusterName}'

@description('Azure region for all resources')
param location string = resourceGroup().location

@description('Kubernetes version')
@allowed([
  '1.29.2'
  '1.28.5'
  '1.27.9'
])
param kubernetesVersion string = '${kubernetesVersion}'

@description('Control plane node count for high availability')
@minValue(1)
@maxValue(5)
param controlPlaneCount int = ${controlPlaneCount}

// Azure Arc-enabled Kubernetes cluster
resource aksCluster 'Microsoft.Kubernetes/connectedClusters@2024-01-01' = {
  name: clusterName
  location: location
  properties: {
    agentPublicKeyCertificate: ''
    // Availability sets are enabled by default
    // VMs will automatically spread across ${availabilitySetConfig.faultDomains} physical hosts
  }
}

`;

        // Add Log Analytics workspace if Defender is enabled
        if (enableDefender) {
            template += `
// Log Analytics Workspace (required for Defender for Containers)
resource logAnalytics 'Microsoft.OperationalInsights/workspaces@2022-10-01' = {
  name: '\${clusterName}-logs'
  location: location
  properties: {
    sku: {
      name: 'PerGB2018'
    }
    retentionInDays: 90
    features: {
      enableLogAccessUsingOnlyResourcePermissions: true
    }
  }
}

// Microsoft Defender for Containers
resource defenderForContainers 'Microsoft.Security/pricings@2023-01-01' = {
  name: 'Containers'
  properties: {
    pricingTier: 'Standard'
  }
}
`;
        }

        // Add Azure Policy assignment if enabled
        if (enablePolicy) {
            template += `
// Azure Policy - Kubernetes cluster pod security baseline standards
resource policyAssignment 'Microsoft.Authorization/policyAssignments@2023-04-01' = {
  name: 'k8s-pod-security-baseline'
  location: location
  identity: {
    type: 'SystemAssigned'
  }
  properties: {
    displayName: 'Kubernetes cluster pod security baseline standards'
    description: 'This initiative includes the policies for the Kubernetes cluster pod security baseline standards'
    policyDefinitionId: '/providers/Microsoft.Authorization/policySetDefinitions/a8640138-9b0a-4a28-b8cb-1666c838647d'
    parameters: {
      effect: {
        value: 'Audit'
      }
    }
  }
}
`;
        }

        // Add node pools
        nodePools.forEach((pool, i) => {
            template += `
// Node Pool: ${pool.name}
resource nodePool${i} 'Microsoft.ContainerService/managedClusters/agentPools@2024-01-01' = {
  name: '${pool.name}'
  properties: {
    count: ${pool.nodeCount}
    vmSize: '${pool.vmSize}'
    osType: '${pool.osType}'
    mode: '${pool.mode}'
    enableAutoScaling: ${pool.enableAutoScaling}
    ${pool.minCount ? `minCount: ${pool.minCount}` : ''}
    ${pool.maxCount ? `maxCount: ${pool.maxCount}` : ''}
    maxPods: ${pool.maxPods}
    nodeLabels: {
${Object.entries(pool.labels).map(([k, v]) => `      '${k}': '${v}'`).join('\n')}
    }
${pool.taints ? `    nodeTaints: [\n${pool.taints.map(t => `      '${t}'`).join('\n')}\n    ]` : ''}
  }
}
`;
        });

        template += `
output clusterName string = aksCluster.name
output clusterId string = aksCluster.id
${enableDefender ? `output logAnalyticsWorkspaceId string = logAnalytics.id` : ''}
`;

        return template;
    }

    /**
     * Generate ARM template
     */
    static generateARM(plan) {
        const { clusterConfig } = plan;
        const { clusterName, location, kubernetesVersion, nodePools } = clusterConfig;

        const resources = [
            {
                type: 'Microsoft.Kubernetes/connectedClusters',
                apiVersion: '2024-01-01',
                name: '[parameters(\'clusterName\')]',
                location: '[parameters(\'location\')]',
                properties: {
                    agentPublicKeyCertificate: ''
                }
            }
        ];

        // Add node pools
        nodePools.forEach((pool, i) => {
            const poolResource = {
                type: 'Microsoft.ContainerService/managedClusters/agentPools',
                apiVersion: '2024-01-01',
                name: `[concat(parameters('clusterName'), '/${pool.name}')]`,
                properties: {
                    count: pool.nodeCount,
                    vmSize: pool.vmSize,
                    osType: pool.osType,
                    mode: pool.mode,
                    enableAutoScaling: pool.enableAutoScaling,
                    maxPods: pool.maxPods,
                    nodeLabels: pool.labels
                },
                dependsOn: [
                    '[resourceId(\'Microsoft.Kubernetes/connectedClusters\', parameters(\'clusterName\'))]'
                ]
            };

            if (pool.minCount) poolResource.properties.minCount = pool.minCount;
            if (pool.maxCount) poolResource.properties.maxCount = pool.maxCount;
            if (pool.taints) poolResource.properties.nodeTaints = pool.taints;

            resources.push(poolResource);
        });

        const template = {
            '$schema': 'https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#',
            contentVersion: '1.0.0.0',
            metadata: {
                _generator: {
                    name: 'AKS Arc Deployment Tool',
                    version: '0.1.0'
                }
            },
            parameters: {
                clusterName: {
                    type: 'string',
                    defaultValue: clusterName,
                    metadata: {
                        description: 'Name of the AKS Arc cluster'
                    }
                },
                location: {
                    type: 'string',
                    defaultValue: location,
                    metadata: {
                        description: 'Azure region'
                    }
                },
                kubernetesVersion: {
                    type: 'string',
                    defaultValue: kubernetesVersion,
                    metadata: {
                        description: 'Kubernetes version'
                    }
                }
            },
            variables: {},
            resources,
            outputs: {
                clusterName: {
                    type: 'string',
                    value: '[parameters(\'clusterName\')]'
                },
                clusterId: {
                    type: 'string',
                    value: '[resourceId(\'Microsoft.Kubernetes/connectedClusters\', parameters(\'clusterName\'))]'
                }
            }
        };

        return JSON.stringify(template, null, 2);
    }

    /**
     * Generate Terraform configuration
     */
    static generateTerraform(plan) {
        const { clusterConfig } = plan;
        const { clusterName, resourceGroup, location, kubernetesVersion, nodePools } = clusterConfig;

        let template = `# AKS Arc Cluster Deployment
# Generated by AKS Arc Deployment Tool
# Generated: ${new Date().toISOString()}

terraform {
  required_version = ">= 1.6"
  
  required_providers {
    azapi = {
      source  = "Azure/azapi"
      version = "~> 1.12"
    }
    azurerm = {
      source  = "hashicorp/azurerm"
      version = "~> 3.80"
    }
  }
}

provider "azurerm" {
  features {}
}

provider "azapi" {}

variable "cluster_name" {
  type        = string
  default     = "${clusterName}"
  description = "Name of the AKS Arc cluster"
}

variable "resource_group" {
  type        = string
  default     = "${resourceGroup}"
  description = "Resource group name"
}

variable "location" {
  type        = string
  default     = "${location}"
  description = "Azure region"
}

variable "kubernetes_version" {
  type        = string
  default     = "${kubernetesVersion}"
  description = "Kubernetes version"
}

data "azurerm_subscription" "current" {}

# Azure Arc-enabled Kubernetes Cluster
resource "azapi_resource" "aks_arc_cluster" {
  type      = "Microsoft.Kubernetes/connectedClusters@2024-01-01"
  name      = var.cluster_name
  parent_id = "/subscriptions/\${data.azurerm_subscription.current.subscription_id}/resourceGroups/\${var.resource_group}"
  location  = var.location
  
  body = jsonencode({
    properties = {
      agentPublicKeyCertificate = ""
    }
  })
}

`;

        // Add node pools
        nodePools.forEach((pool) => {
            template += `
# Node Pool: ${pool.name}
resource "azapi_resource" "nodepool_${pool.name}" {
  type      = "Microsoft.ContainerService/managedClusters/agentPools@2024-01-01"
  name      = "${pool.name}"
  parent_id = azapi_resource.aks_arc_cluster.id
  
  body = jsonencode({
    properties = {
      count             = ${pool.nodeCount}
      vmSize            = "${pool.vmSize}"
      osType            = "${pool.osType}"
      mode              = "${pool.mode}"
      enableAutoScaling = ${pool.enableAutoScaling}
      ${pool.minCount ? `minCount          = ${pool.minCount}` : ''}
      ${pool.maxCount ? `maxCount          = ${pool.maxCount}` : ''}
      maxPods           = ${pool.maxPods}
      nodeLabels = {
${Object.entries(pool.labels).map(([k, v]) => `        "${k}" = "${v}"`).join('\n')}
      }
${pool.taints ? `      nodeTaints = [\n${pool.taints.map(t => `        "${t}"`).join(',\n')}\n      ]` : ''}
    }
  })
}
`;
        });

        template += `
output "cluster_name" {
  value       = azapi_resource.aks_arc_cluster.name
  description = "The name of the AKS Arc cluster"
}

output "cluster_id" {
  value       = azapi_resource.aks_arc_cluster.id
  description = "The resource ID of the AKS Arc cluster"
}
`;

        return template;
    }

    /**
     * Download file helper
     */
    static downloadFile(content, filename, mimeType = 'text/plain') {
        const blob = new Blob([content], { type: mimeType });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
    }
}

// Export for use in other modules
if (typeof module !== 'undefined' && module.exports) {
    module.exports = TemplateGenerator;
}
