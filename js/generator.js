/**
 * Template Generators - Bicep, ARM, Terraform
 * VERSION: 2025-12-17-1700 (Parameter fix with defense-in-depth)
 */
console.log('âœ… generator.js loaded - VERSION: 2025-12-17-1700');

class TemplateGenerator {
    /**
     * Generate Bicep template
     */
    static generateBicep(plan) {
        const { clusterConfig, networkConfig, storageConfig, availabilitySetConfig, securityConfig } = plan;
        const { clusterName, location, kubernetesVersion, controlPlaneCount, controlPlaneVmSize, nodePools, customLocation, logicalNetwork } = clusterConfig;
        const { controlPlaneIP, podCIDR } = networkConfig || {};
        const enableDefender = securityConfig?.enableDefender || false;
        const enablePolicy = securityConfig?.enablePolicy !== false;

        let template = `// AKS Arc Cluster Deployment
// Generated by AKS Arc Deployment Tool
// Generated: ${new Date().toISOString()}
//
// Resource Type: Microsoft.HybridContainerService/provisionedClusterInstances
// This is the correct resource type for AKS enabled by Azure Arc on Azure Local
//
// High Availability: Availability sets are enabled by default in AKS Arc
// - Control plane VMs automatically spread across physical hosts
// - Each node pool has its own availability set with anti-affinity rules
// - VMs automatically rebalance when hosts recover from outages
// - Physical hosts: ${availabilitySetConfig?.faultDomains || 'N/A'}
//
// Security Configuration:
// - Microsoft Defender for Containers: ${enableDefender ? 'ENABLED (~$6.87/vCore/month)' : 'DISABLED'}
// - Azure Policy for Kubernetes: ${enablePolicy ? 'ENABLED (FREE)' : 'DISABLED'}
//
// Recommendation: Configure pod anti-affinity rules in your workload deployments
// for additional resilience across nodes.

targetScope = 'resourceGroup'

@description('Name of the AKS Arc cluster')
param clusterName string = '${clusterName}'

@description('Azure region for all resources')
param location string = '${location}'

@description('Kubernetes version')
param kubernetesVersion string = '${kubernetesVersion}'

@description('Control plane node count for high availability')
@minValue(1)
@maxValue(5)
param controlPlaneCount int = ${controlPlaneCount || 1}

@description('VM size for control plane nodes')
param controlPlaneVmSize string = '${controlPlaneVmSize || 'Standard_A4_v2'}'

@description('ARM resource ID of the Custom Location')
param customLocation string = '${customLocation || ''}'

@description('ARM resource ID of the Logical Network')
param logicalNetwork string = '${logicalNetwork || ''}'

@description('Pod CIDR for Kubernetes networking')
param podCIDR string = '${podCIDR || '10.244.0.0/16'}'

@description('SSH public key for node access')
@secure()
param sshPublicKey string
${controlPlaneIP ? `
@description('Static IP for control plane endpoint')
param controlPlaneIP string = '${controlPlaneIP}'
` : ''}

// Connected Cluster - Arc representation for Managed Identity
resource connectedCluster 'Microsoft.Kubernetes/ConnectedClusters@2024-01-01' = {
  name: clusterName
  location: location
  identity: {
    type: 'SystemAssigned'
  }
  kind: 'ProvisionedCluster'
  properties: {
    agentPublicKeyCertificate: ''
    aadProfile: {
      enableAzureRBAC: false
    }
  }
}

// Provisioned Cluster Instance - The actual AKS Arc cluster
resource provisionedCluster 'Microsoft.HybridContainerService/provisionedClusterInstances@2025-02-01-preview' = {
  name: 'default'
  scope: connectedCluster
  extendedLocation: {
    name: customLocation
    type: 'CustomLocation'
  }
  properties: {
    kubernetesVersion: kubernetesVersion
    controlPlane: {
      count: controlPlaneCount
      vmSize: controlPlaneVmSize${controlPlaneIP ? `
      controlPlaneEndpoint: {
        hostIP: controlPlaneIP
      }` : ''}
    }
    agentPoolProfiles: [
`;

        // Add agent pool profiles
        nodePools.forEach((pool, i) => {
            template += `      {
        name: '${pool.name}'
        count: ${pool.nodeCount}
        vmSize: '${pool.vmSize}'
        osType: '${pool.osType || 'Linux'}'
        osSKU: '${pool.osType === 'Windows' ? 'Windows2022' : 'CBLMariner'}'
        maxPods: ${pool.maxPods || 110}`;
            
            if (pool.enableAutoScaling) {
                template += `
        enableAutoScaling: true
        minCount: ${pool.minCount || pool.nodeCount}
        maxCount: ${pool.maxCount || pool.nodeCount * 2}`;
            }
            
            if (pool.labels && Object.keys(pool.labels).length > 0) {
                template += `
        nodeLabels: {
${Object.entries(pool.labels).map(([k, v]) => `          '${k}': '${v}'`).join('\n')}
        }`;
            }
            
            if (pool.taints && pool.taints.length > 0) {
                template += `
        nodeTaints: [
${pool.taints.map(t => `          '${t}'`).join('\n')}
        ]`;
            }
            
            template += `
      }${i < nodePools.length - 1 ? ',' : ''}
`;
        });

        template += `    ]
    cloudProviderProfile: {
      infraNetworkProfile: {
        vnetSubnetIds: [
          logicalNetwork
        ]
      }
    }
    networkProfile: {
      podCidr: podCIDR
      networkPolicy: 'calico'
      loadBalancerProfile: {
        count: 0  // Use MetalLB
      }
    }
    linuxProfile: {
      ssh: {
        publicKeys: [
          {
            keyData: sshPublicKey
          }
        ]
      }
    }`;

        // Add storage profile if configured
        if (storageConfig && (storageConfig.nfsCsiDriver || storageConfig.smbCsiDriver)) {
            template += `
    storageProfile: {`;
            if (storageConfig.nfsCsiDriver) {
                template += `
      nfsCsiDriver: {
        enabled: true
      }`;
            }
            if (storageConfig.smbCsiDriver) {
                template += `
      smbCsiDriver: {
        enabled: true
      }`;
            }
            template += `
    }`;
        }

        template += `
  }
}
`;

        // Add Log Analytics workspace if Defender is enabled
        if (enableDefender) {
            template += `
// Log Analytics Workspace (required for Defender for Containers)
resource logAnalytics 'Microsoft.OperationalInsights/workspaces@2022-10-01' = {
  name: '\${clusterName}-logs'
  location: location
  properties: {
    sku: {
      name: 'PerGB2018'
    }
    retentionInDays: 90
    features: {
      enableLogAccessUsingOnlyResourcePermissions: true
    }
  }
}

// Microsoft Defender for Containers
resource defenderForContainers 'Microsoft.Security/pricings@2023-01-01' = {
  name: 'Containers'
  properties: {
    pricingTier: 'Standard'
  }
}
`;
        }

        // Add Azure Policy assignment if enabled
        if (enablePolicy) {
            template += `
// Azure Policy - Kubernetes cluster pod security baseline standards
resource policyAssignment 'Microsoft.Authorization/policyAssignments@2023-04-01' = {
  name: 'k8s-pod-security-baseline'
  location: location
  identity: {
    type: 'SystemAssigned'
  }
  properties: {
    displayName: 'Kubernetes cluster pod security baseline standards'
    description: 'This initiative includes the policies for the Kubernetes cluster pod security baseline standards'
    policyDefinitionId: '/providers/Microsoft.Authorization/policySetDefinitions/a8640138-9b0a-4a28-b8cb-1666c838647d'
    parameters: {
      effect: {
        value: 'Audit'
      }
    }
  }
}
`;
        }

        template += `
output clusterName string = connectedCluster.name
output connectedClusterId string = connectedCluster.id
output provisionedClusterId string = provisionedCluster.id
${enableDefender ? `output logAnalyticsWorkspaceId string = logAnalytics.id` : ''}
`;

        return template;
    }

    /**
     * Generate ARM template
     */
    static generateARM(plan) {
        const { clusterConfig, networkConfig, storageConfig } = plan;
        const { clusterName, location, kubernetesVersion, controlPlaneCount, controlPlaneVmSize, nodePools, customLocation, logicalNetwork } = clusterConfig;
        const { controlPlaneIP, podCIDR } = networkConfig || {};
        
        // Debug logging
        console.log('ðŸ” generateARM called with clusterName:', clusterName, 'customLocation:', customLocation);
        
        // Handle undefined values - convert to empty string for ARM template
        const clusterNameValue = clusterName || '';
        const customLocationValue = customLocation || '';
        const logicalNetworkValue = logicalNetwork || '';
        const controlPlaneIPValue = controlPlaneIP || '';
        
        console.log('âœ… Safe values - clusterName:', clusterNameValue, 'customLocation:', customLocationValue);
        
        // Build agent pool profiles array
        const agentPoolProfiles = nodePools.map(pool => {
            const profile = {
                name: pool.name,
                count: pool.nodeCount,
                vmSize: pool.vmSize,
                osType: pool.osType || 'Linux',
                osSKU: pool.osType === 'Windows' ? 'Windows2022' : 'CBLMariner',
                maxPods: pool.maxPods || 110
            };

            if (pool.enableAutoScaling) {
                profile.enableAutoScaling = true;
                profile.minCount = pool.minCount || pool.nodeCount;
                profile.maxCount = pool.maxCount || pool.nodeCount * 2;
            }

            if (pool.labels && Object.keys(pool.labels).length > 0) {
                profile.nodeLabels = pool.labels;
            }

            if (pool.taints && pool.taints.length > 0) {
                profile.nodeTaints = pool.taints;
            }

            return profile;
        });

        const resources = [
            // Connected Cluster - Arc representation for Managed Identity
            {
                type: 'Microsoft.Kubernetes/ConnectedClusters',
                apiVersion: '2024-01-01',
                name: '[parameters(\'clusterName\')]',
                location: '[parameters(\'location\')]',
                identity: {
                    type: 'SystemAssigned'
                },
                kind: 'ProvisionedCluster',
                properties: {
                    agentPublicKeyCertificate: '',
                    aadProfile: {
                        enableAzureRBAC: false
                    }
                }
            },
            // Provisioned Cluster Instance - The actual AKS Arc cluster
            {
                type: 'Microsoft.HybridContainerService/provisionedClusterInstances',
                apiVersion: '2025-02-01-preview',
                name: 'default',
                scope: '[format(\'Microsoft.Kubernetes/ConnectedClusters/{0}\', parameters(\'clusterName\'))]',
                extendedLocation: {
                    name: '[parameters(\'customLocation\')]',
                    type: 'CustomLocation'
                },
                properties: {
                    kubernetesVersion: '[parameters(\'kubernetesVersion\')]',
                    controlPlane: {
                        count: '[parameters(\'controlPlaneCount\')]',
                        vmSize: '[parameters(\'controlPlaneVmSize\')]',
                        ...(controlPlaneIP && {
                            controlPlaneEndpoint: {
                                hostIP: '[parameters(\'controlPlaneIP\')]'
                            }
                        })
                    },
                    agentPoolProfiles,
                    cloudProviderProfile: {
                        infraNetworkProfile: {
                            vnetSubnetIds: [
                                '[parameters(\'logicalNetwork\')]'
                            ]
                        }
                    },
                    networkProfile: {
                        podCidr: '[parameters(\'podCIDR\')]',
                        networkPolicy: 'calico',
                        loadBalancerProfile: {
                            count: 0
                        }
                    },
                    linuxProfile: {
                        ssh: {
                            publicKeys: [
                                {
                                    keyData: '[parameters(\'sshPublicKey\')]'
                                }
                            ]
                        }
                    }
                },
                dependsOn: [
                    '[resourceId(\'Microsoft.Kubernetes/ConnectedClusters\', parameters(\'clusterName\'))]'
                ]
            }
        ];

        // Add storage profile if CSI drivers are configured
        if (storageConfig && (storageConfig.nfsCsiDriver || storageConfig.smbCsiDriver)) {
            resources[1].properties.storageProfile = {};
            if (storageConfig.nfsCsiDriver) {
                resources[1].properties.storageProfile.nfsCsiDriver = {
                    enabled: true
                };
            }
            if (storageConfig.smbCsiDriver) {
                resources[1].properties.storageProfile.smbCsiDriver = {
                    enabled: true
                };
            }
        }

        const template = {
            '$schema': 'https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#',
            contentVersion: '1.0.0.0',
            metadata: {
                _generator: {
                    name: 'AKS Arc Deployment Tool',
                    version: '2.0.1-HOTFIX-20251217',
                    templateType: 'AKS enabled by Azure Arc on Azure Local',
                    generatedAt: new Date().toISOString()
                },
                description: 'ARM template for deploying AKS Arc cluster using Microsoft.HybridContainerService/provisionedClusterInstances'
            },
            parameters: {
                clusterName: {
                    type: 'string',
                    defaultValue: clusterNameValue,
                    metadata: {
                        description: 'Name of the AKS Arc cluster'
                    }
                },
                location: {
                    type: 'string',
                    defaultValue: location || 'eastus',
                    metadata: {
                        description: 'Azure region for the cluster'
                    }
                },
                kubernetesVersion: {
                    type: 'string',
                  defaultValue: kubernetesVersion || '1.27.9',
                    metadata: {
                    description: 'Kubernetes version (must be supported by your AKS Arc on Azure Local installation)'
                    }
                },
                controlPlaneCount: {
                    type: 'int',
                    defaultValue: controlPlaneCount || 1,
                    minValue: 1,
                    maxValue: 5,
                    metadata: {
                        description: 'Number of control plane nodes (1, 3, or 5 for high availability)'
                    }
                },
                controlPlaneVmSize: {
                    type: 'string',
                    defaultValue: controlPlaneVmSize || 'Standard_A4_v2',
                    metadata: {
                        description: 'VM size for control plane nodes'
                    }
                },
                customLocation: {
                    type: 'string',
                    defaultValue: customLocationValue,
                    metadata: {
                        description: 'ARM resource ID of the Custom Location for your Azure Local cluster'
                    }
                },
                logicalNetwork: {
                    type: 'string',
                    defaultValue: logicalNetworkValue,
                    metadata: {
                        description: 'ARM resource ID of the Logical Network for VM network interfaces'
                    }
                },
                podCIDR: {
                    type: 'string',
                    defaultValue: podCIDR || '10.244.0.0/16',
                    metadata: {
                        description: 'CIDR range for Kubernetes pods'
                    }
                },
                sshPublicKey: {
                    type: 'securestring',
                    metadata: {
                        description: 'SSH public key for node access (e.g., ssh-rsa AAAA...)'
                    }
                },
                ...(controlPlaneIPValue && {
                    controlPlaneIP: {
                        type: 'string',
                        defaultValue: controlPlaneIPValue,
                        metadata: {
                            description: 'Static IP address for control plane endpoint (optional)'
                        }
                    }
                })
            },
            variables: {},
            resources,
            outputs: {
                clusterName: {
                    type: 'string',
                    value: '[parameters(\'clusterName\')]'
                },
                connectedClusterId: {
                    type: 'string',
                    value: '[resourceId(\'Microsoft.Kubernetes/ConnectedClusters\', parameters(\'clusterName\'))]'
                },
                provisionedClusterInstanceId: {
                    type: 'string',
                    value: '[extensionResourceId(resourceId(\'Microsoft.Kubernetes/ConnectedClusters\', parameters(\'clusterName\')), \'Microsoft.HybridContainerService/provisionedClusterInstances\', \'default\')]'
                }
            }
        };

        // Custom JSON replacer to ensure empty strings stay as empty strings, not {}
        const jsonString = JSON.stringify(template, (key, value) => {
            // If value is undefined, convert to empty string for string parameters
            if (value === undefined && key !== 'defaultValue') {
                return value; // Keep undefined for non-defaultValue keys
            }
            // If this is a defaultValue and it's undefined or null, use empty string
            if (key === 'defaultValue' && (value === undefined || value === null)) {
                return '';
            }
            return value;
        }, 2);
        
        console.log('âœ… ARM template generated, length:', jsonString.length);
        return jsonString;
    }

    /**
     * Generate Terraform configuration
     */
    static generateTerraform(plan) {
        const { clusterConfig, networkConfig, storageConfig } = plan;
        const { clusterName, resourceGroup, location, kubernetesVersion, controlPlaneCount, controlPlaneVmSize, nodePools, customLocation, logicalNetwork } = clusterConfig;
        const { controlPlaneIP, podCIDR } = networkConfig || {};

        let template = `# AKS Arc Cluster Deployment
# Generated by AKS Arc Deployment Tool
# Generated: ${new Date().toISOString()}
# Resource Type: Microsoft.HybridContainerService/provisionedClusterInstances
# This is the correct resource type for AKS enabled by Azure Arc on Azure Local

terraform {
  required_version = ">= 1.6"
  
  required_providers {
    azapi = {
      source  = "Azure/azapi"
      version = "~> 1.12"
    }
    azurerm = {
      source  = "hashicorp/azurerm"
      version = "~> 3.80"
    }
  }
}

provider "azurerm" {
  features {}
}

provider "azapi" {}

variable "cluster_name" {
  type        = string
  default     = "${clusterName}"
  description = "Name of the AKS Arc cluster"
}

variable "resource_group" {
  type        = string
  default     = "${resourceGroup || ''}"
  description = "Resource group name"
}

variable "location" {
  type        = string
  default     = "${location}"
  description = "Azure region"
}

variable "kubernetes_version" {
  type        = string
  default     = "${kubernetesVersion}"
  description = "Kubernetes version"
}

variable "control_plane_count" {
  type        = number
  default     = ${controlPlaneCount || 1}
  description = "Number of control plane nodes (1, 3, or 5)"
}

variable "control_plane_vm_size" {
  type        = string
  default     = "${controlPlaneVmSize || 'Standard_A4_v2'}"
  description = "VM size for control plane nodes"
}

variable "custom_location" {
  type        = string
  default     = "${customLocation || ''}"
  description = "ARM resource ID of the Custom Location"
}

variable "logical_network" {
  type        = string
  default     = "${logicalNetwork || ''}"
  description = "ARM resource ID of the Logical Network"
}

variable "pod_cidr" {
  type        = string
  default     = "${podCIDR || '10.244.0.0/16'}"
  description = "CIDR range for Kubernetes pods"
}

variable "ssh_public_key" {
  type        = string
  sensitive   = true
  description = "SSH public key for node access"
}
${controlPlaneIP ? `
variable "control_plane_ip" {
  type        = string
  default     = "${controlPlaneIP}"
  description = "Static IP for control plane endpoint"
}
` : ''}

data "azurerm_subscription" "current" {}

# Connected Cluster - Arc representation for Managed Identity
resource "azapi_resource" "connected_cluster" {
  type      = "Microsoft.Kubernetes/ConnectedClusters@2024-01-01"
  name      = var.cluster_name
  parent_id = "/subscriptions/\${data.azurerm_subscription.current.subscription_id}/resourceGroups/\${var.resource_group}"
  location  = var.location
  
  identity {
    type = "SystemAssigned"
  }
  
  body = jsonencode({
    kind = "ProvisionedCluster"
    properties = {
      agentPublicKeyCertificate = ""
      aadProfile = {
        enableAzureRBAC = false
      }
    }
  })
}

# Provisioned Cluster Instance - The actual AKS Arc cluster
resource "azapi_resource" "provisioned_cluster" {
  type      = "Microsoft.HybridContainerService/provisionedClusterInstances@2025-02-01-preview"
  name      = "default"
  parent_id = azapi_resource.connected_cluster.id
  
  body = jsonencode({
    extendedLocation = {
      name = var.custom_location
      type = "CustomLocation"
    }
    properties = {
      kubernetesVersion = var.kubernetes_version
      controlPlane = {
        count  = var.control_plane_count
        vmSize = var.control_plane_vm_size${controlPlaneIP ? `
        controlPlaneEndpoint = {
          hostIP = var.control_plane_ip
        }` : ''}
      }
      agentPoolProfiles = [
`;

        // Add agent pool profiles
        nodePools.forEach((pool, i) => {
            template += `        {
          name    = "${pool.name}"
          count   = ${pool.nodeCount}
          vmSize  = "${pool.vmSize}"
          osType  = "${pool.osType || 'Linux'}"
          osSKU   = "${pool.osType === 'Windows' ? 'Windows2022' : 'CBLMariner'}"
          maxPods = ${pool.maxPods || 110}`;

            if (pool.enableAutoScaling) {
                template += `
          enableAutoScaling = true
          minCount          = ${pool.minCount || pool.nodeCount}
          maxCount          = ${pool.maxCount || pool.nodeCount * 2}`;
            }

            if (pool.labels && Object.keys(pool.labels).length > 0) {
                template += `
          nodeLabels = {
${Object.entries(pool.labels).map(([k, v]) => `            "${k}" = "${v}"`).join('\n')}
          }`;
            }

            if (pool.taints && pool.taints.length > 0) {
                template += `
          nodeTaints = [
${pool.taints.map(t => `            "${t}"`).join(',\n')}
          ]`;
            }

            template += `
        }${i < nodePools.length - 1 ? ',' : ''}
`;
        });

        template += `      ]
      cloudProviderProfile = {
        infraNetworkProfile = {
          vnetSubnetIds = [
            var.logical_network
          ]
        }
      }
      networkProfile = {
        podCidr        = var.pod_cidr
        networkPolicy  = "calico"
        loadBalancerProfile = {
          count = 0  # Use MetalLB
        }
      }
      linuxProfile = {
        ssh = {
          publicKeys = [
            {
              keyData = var.ssh_public_key
            }
          ]
        }
      }`;

        // Add storage profile if configured
        if (storageConfig && (storageConfig.nfsCsiDriver || storageConfig.smbCsiDriver)) {
            template += `
      storageProfile = {`;
            if (storageConfig.nfsCsiDriver) {
                template += `
        nfsCsiDriver = {
          enabled = true
        }`;
            }
            if (storageConfig.smbCsiDriver) {
                template += `
        smbCsiDriver = {
          enabled = true
        }`;
            }
            template += `
      }`;
        }

        template += `
    }
  })
  
  depends_on = [
    azapi_resource.connected_cluster
  ]
}

output "cluster_name" {
  value       = azapi_resource.connected_cluster.name
  description = "The name of the AKS Arc cluster"
}

output "connected_cluster_id" {
  value       = azapi_resource.connected_cluster.id
  description = "The resource ID of the Connected Cluster"
}

output "provisioned_cluster_id" {
  value       = azapi_resource.provisioned_cluster.id
  description = "The resource ID of the Provisioned Cluster Instance"
}
`;

        return template;
    }

    /**
     * Download file helper
     */
    static downloadFile(content, filename, mimeType = 'text/plain') {
        const blob = new Blob([content], { type: mimeType });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
    }
}

// Export for use in other modules
if (typeof module !== 'undefined' && module.exports) {
    module.exports = TemplateGenerator;
}
